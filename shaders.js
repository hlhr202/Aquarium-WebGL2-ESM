const shaders = [
  {
    id: "texVertexShader",
    content:
      "\nattribute vec4 position;\nattribute vec2 texCoord;\nvarying vec2 v_texCoord;\nuniform mat4 world;\nuniform mat4 viewProjection;\nvoid main() {\n  v_texCoord = texCoord;\n  gl_Position = (viewProjection * world * position);\n}\n",
  },
  {
    id: "texFragmentShader",
    content:
      "\nprecision mediump float;\n\nvarying vec2 v_texCoord;\nuniform vec4 colorMult;\nuniform sampler2D colorMap;\nvoid main() {\n  gl_FragColor = texture2D(colorMap, v_texCoord) * colorMult;\n}\n",
  },
  {
    id: "laserVertexShader",
    content:
      "\nattribute vec4 position;\nattribute vec2 texCoord;\nvarying vec2 v_texCoord;\nuniform mat4 world;\nuniform mat4 viewProjection;\nvoid main() {\n  v_texCoord = texCoord;\n  gl_Position = (viewProjection * world * position);\n}\n",
  },
  {
    id: "laserFragmentShader",
    content:
      "\nprecision mediump float;\n\nvarying vec2 v_texCoord;\nuniform vec4 colorMult;\nuniform sampler2D colorMap;\nvoid main() {\n  gl_FragColor = texture2D(colorMap, v_texCoord) * colorMult;\n}\n",
  },
  {
    id: "fishVertexShader",
    content:
      "\nuniform vec3 lightWorldPos;\nuniform mat4 viewInverse;\nuniform mat4 viewProjection;\nuniform vec3 worldPosition;\nuniform vec3 nextPosition;\nuniform float scale;\nuniform float time;\nuniform float fishLength;\nuniform float fishWaveLength;\nuniform float fishBendAmount;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nattribute vec3 tangent;  // #normalMap\nattribute vec3 binormal;  // #normalMap\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  vec3 vz = normalize(worldPosition - nextPosition);\n  vec3 vx = normalize(cross(vec3(0,1,0), vz));\n  vec3 vy = cross(vz, vx);\n  mat4 orientMat = mat4(\n    vec4(vx, 0),\n    vec4(vy, 0),\n    vec4(vz, 0),\n    vec4(worldPosition, 1));\n  mat4 scaleMat = mat4(\n    vec4(scale, 0, 0, 0),\n    vec4(0, scale, 0, 0),\n    vec4(0, 0, scale, 0),\n    vec4(0, 0, 0, 1));\n  mat4 world = orientMat * scaleMat;\n  mat4 worldInverseTranspose = world;\n\n  v_texCoord = texCoord;\n  // NOTE:If you change this you need to change the laser code to match!\n  float mult = position.z > 0.0 ?\n      (position.z / fishLength) :\n      (-position.z / fishLength * 2.0);\n  float s = sin(time + mult * fishWaveLength);\n  float a = sign(s);\n  float offset = pow(mult, 2.0) * s * fishBendAmount;\n  v_position = (\n      viewProjection * world *\n      (position +\n       vec4(offset, 0, 0, 0)));\n  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  v_binormal = (worldInverseTranspose * vec4(binormal, 0)).xyz;  // #normalMap\n  v_tangent = (worldInverseTranspose * vec4(tangent, 0)).xyz;  // #normalMap\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "fishNormalMapFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform vec4 ambient;\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform sampler2D normalMap;  // #normalMap\nuniform float shininess;\nuniform float specularFactor;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  mat3 tangentToWorld = mat3(v_tangent,  // #normalMap\n                             v_binormal,  // #normalMap\n                             v_normal);  // #normalMap\n  vec4 normalSpec = texture2D(normalMap, v_texCoord.xy);  // #normalMap\n  vec4 normalSpec = vec4(0,0,0,0);  // #noNormalMap\n  vec3 tangentNormal = normalSpec.xyz - vec3(0.5, 0.5, 0.5);  // #normalMap\n  tangentNormal = normalize(tangentNormal + vec3(0, 0, 2));  // #normalMap\n  vec3 normal = (tangentToWorld * tangentNormal);  // #normalMap\n  normal = normalize(normal);  // #normalMap\n  vec3 normal = normalize(v_normal);   // #noNormalMap\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\n  vec4 litR = lit(dot(normal, surfaceToLight),\n                    dot(normal, halfVector), shininess);\n  vec4 outColor = vec4(\n    (lightColor * (diffuseColor * litR.y + diffuseColor * ambient +\n                  specular * litR.z * specularFactor * normalSpec.a)).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "fishReflectionFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform vec4 ambient;\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform sampler2D normalMap;\nuniform sampler2D reflectionMap; // #reflection\nuniform samplerCube skybox; // #reflecton\nuniform float shininess;\nuniform float specularFactor;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  mat3 tangentToWorld = mat3(v_tangent,  // #normalMap\n                             v_binormal,  // #normalMap\n                             v_normal);  // #normalMap\n  vec4 normalSpec = texture2D(normalMap, v_texCoord.xy);  // #normalMap\n  vec4 normalSpec = vec4(0,0,0,0);  // #noNormalMap\n  vec4 reflection = texture2D(reflectionMap, v_texCoord.xy); // #reflection\n  vec4 reflection = vec4(0,0,0,0);  // #noReflection\n  vec3 tangentNormal = normalSpec.xyz - vec3(0.5, 0.5, 0.5);  // #normalMap\n  vec3 normal = (tangentToWorld * tangentNormal);  // #normalMap\n  normal = normalize(normal);  // #normalMap\n  vec3 normal = normalize(v_normal); // #noNormalMap\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n  vec4 skyColor = textureCube(skybox, -reflect(surfaceToView, normal));  // #reflection\n  vec4 skyColor = vec4(0.5,0.5,1,1);  // #noReflection\n\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\n  vec4 litR = lit(dot(normal, surfaceToLight),\n                    dot(normal, halfVector), shininess);\n  vec4 outColor = vec4(mix(\n      skyColor,\n      lightColor * (diffuseColor * litR.y + diffuseColor * ambient +\n                    specular * litR.z * specularFactor * normalSpec.a),\n      1.0 - reflection.r).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "seaweedVertexShader",
    content:
      "\nuniform mat4 world;\nuniform mat4 viewProjection;\nuniform vec3 lightWorldPos;\nuniform mat4 viewInverse;\nuniform mat4 worldInverseTranspose;\nuniform float time;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  vec3 toCamera = normalize(viewInverse[3].xyz - world[3].xyz);\n  vec3 yAxis = vec3(0, 1, 0);\n  vec3 xAxis = cross(yAxis, toCamera);\n  vec3 zAxis = cross(xAxis, yAxis);\n\n  mat4 newWorld = mat4(\n      vec4(xAxis, 0),\n      vec4(yAxis, 0),\n      vec4(xAxis, 0),\n      world[3]);\n\n  v_texCoord = texCoord;\n  v_position = position + vec4(\n      sin(time * 0.5) * pow(position.y * 0.07, 2.0) * 1.0,\n      -4,  // TODO(gman): remove this hack\n      0,\n      0);\n  v_position = (viewProjection * newWorld) * v_position;\n  v_normal = (newWorld * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "seaweedFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform vec4 ambient;\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform float shininess;\nuniform float specularFactor;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  if (diffuseColor.a < 0.3) {\n    discard;\n  }\n  vec3 normal = normalize(v_normal);\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\n  vec4 litR = lit(dot(normal, surfaceToLight),\n                    dot(normal, halfVector), shininess);\n  vec4 outColor = vec4((\n  lightColor * (diffuseColor * litR.y + diffuseColor * ambient +\n                specular * litR.z * specularFactor)).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "diffuseVertexShader",
    content:
      "\nuniform mat4 viewProjection;\nuniform vec3 lightWorldPos;\nuniform mat4 world;\nuniform mat4 viewInverse;\nuniform mat4 worldInverseTranspose;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  v_texCoord = texCoord;\n  v_position = (viewProjection * world * position);\n  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "diffuseFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform vec4 ambient;\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform float shininess;\nuniform float specularFactor;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  vec3 normal = normalize(v_normal);\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\n  vec4 litR = lit(dot(normal, surfaceToLight),\n                    dot(normal, halfVector), shininess);\n  vec4 outColor = vec4((\n  lightColor * (diffuseColor * litR.y + diffuseColor * ambient +\n                specular * litR.z * specularFactor)).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "normalMapVertexShader",
    content:
      "\nuniform mat4 viewProjection;\nuniform vec3 lightWorldPos;\nuniform mat4 world;\nuniform mat4 viewInverse;\nuniform mat4 worldInverseTranspose;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nattribute vec3 tangent;  // #normalMap\nattribute vec3 binormal;  // #normalMap\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  v_texCoord = texCoord;\n  v_position = (viewProjection * world * position);\n  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  v_binormal = (worldInverseTranspose * vec4(binormal, 0)).xyz;  // #normalMap\n  v_tangent = (worldInverseTranspose * vec4(tangent, 0)).xyz;  // #normalMap\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "normalMapFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform vec4 ambient;\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform sampler2D normalMap;  // #normalMap\nuniform float shininess;\nuniform float specularFactor;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  mat3 tangentToWorld = mat3(v_tangent,  // #normalMap\n                             v_binormal,  // #normalMap\n                             v_normal);  // #normalMap\n  vec4 normalSpec = texture2D(normalMap, v_texCoord.xy);  // #normalMap\n  vec4 normalSpec = vec4(0,0,0,0);  // #noNormalMap\n  vec3 tangentNormal = normalSpec.xyz -  // #normalMap\n                                 vec3(0.5, 0.5, 0.5);  // #normalMap\n  vec3 normal = (tangentToWorld * tangentNormal);  // #normalMap\n  normal = normalize(normal);  // #normalMap\n  vec3 normal = normalize(v_normal);   // #noNormalMap\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\n  vec4 litR = lit(dot(normal, surfaceToLight),\n                    dot(normal, halfVector), shininess);\n  vec4 outColor = vec4(\n     (lightColor * (diffuseColor * litR.y + diffuseColor * ambient +\n                    specular * litR.z * specularFactor * normalSpec.a)).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "reflectionMapVertexShader",
    content:
      "\nuniform mat4 viewProjection;\nuniform vec3 lightWorldPos;\nuniform mat4 world;\nuniform mat4 viewInverse;\nuniform mat4 worldInverseTranspose;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nattribute vec3 tangent;\nattribute vec3 binormal;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;\nvarying vec3 v_binormal;\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  v_texCoord = texCoord;\n  v_position = (viewProjection * world * position);\n  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  v_binormal = (worldInverseTranspose * vec4(binormal, 0)).xyz;\n  v_tangent = (worldInverseTranspose * vec4(tangent, 0)).xyz;\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "reflectionMapFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;\nvarying vec3 v_binormal;\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform vec4 ambient;\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform sampler2D normalMap;\nuniform sampler2D reflectionMap;\nuniform samplerCube skybox;\nuniform float shininess;\nuniform float specularFactor;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  mat3 tangentToWorld = mat3(v_tangent,\n                             v_binormal,\n                             v_normal);\n  vec4 normalSpec = texture2D(normalMap, v_texCoord.xy);\n  vec4 reflection = texture2D(reflectionMap, v_texCoord.xy);\n  vec3 tangentNormal = normalSpec.xyz - vec3(0.5, 0.5, 0.5);\n  vec3 normal = (tangentToWorld * tangentNormal);\n  normal = normalize(normal);\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n  vec4 skyColor = textureCube(skybox, -reflect(surfaceToView, normal));\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\n  vec4 litR = lit(dot(normal, surfaceToLight),\n                    dot(normal, halfVector), shininess);\n  vec4 outColor = vec4(mix(\n      skyColor,\n      lightColor * (diffuseColor * litR.y + diffuseColor * ambient +\n                    specular * litR.z * specularFactor * normalSpec.a),\n      1.0 - reflection.r).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "innerRefractionMapVertexShader",
    content:
      "\nuniform mat4 viewProjection;\nuniform vec3 lightWorldPos;\nuniform mat4 world;\nuniform mat4 viewInverse;\nuniform mat4 worldInverseTranspose;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nattribute vec3 tangent;\nattribute vec3 binormal;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  v_texCoord = texCoord;\n  v_position = (viewProjection * world * position);\n  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  v_binormal = (worldInverseTranspose * vec4(binormal, 0)).xyz;  // #normalMap\n  v_tangent = (worldInverseTranspose * vec4(tangent, 0)).xyz;  // #normalMap\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "innerRefractionMapFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform sampler2D normalMap;  // #normalMap\nuniform sampler2D reflectionMap;\nuniform samplerCube skybox;\nuniform float shininess;\nuniform float specularFactor;\nuniform float refractionFudge;\nuniform float eta;\nuniform float tankColorFudge;\n// #fogUniforms\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord) +\n      vec4(tankColorFudge, tankColorFudge, tankColorFudge, 1);\n  mat3 tangentToWorld = mat3(v_tangent,  // #normalMap\n                             v_binormal,  // #normalMap\n                             v_normal);  // #normalMap\n  vec4 normalSpec = texture2D(normalMap, v_texCoord.xy);  // #normalMap\n  vec4 normalSpec = vec4(0,0,0,0);  // #noNormalMap\n  vec4 refraction = texture2D(reflectionMap, v_texCoord.xy);\n  vec3 tangentNormal = normalSpec.xyz - vec3(0.5, 0.5, 0.5);  // #normalMap\n  tangentNormal = normalize(tangentNormal + vec3(0,0,refractionFudge));  // #normalMap\n  vec3 normal = (tangentToWorld * tangentNormal);  // #normalMap\n  normal = normalize(normal);  // #normalMap\n  vec3 normal = normalize(v_normal);   // #noNormalMap\n\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n\n  vec3 refractionVec = refract(surfaceToView, normal, eta);\n\n  vec4 skyColor = textureCube(skybox, refractionVec);\n\n//  vec4 bumpSkyColor = textureCube(skybox, refractionVec);\n//  vec4 nonBumpSkyColor = textureCube(\n//      skybox,\n//      refract(surfaceToView, normalize(v_normal), eta));\n//  vec4 skyColor = mix(nonBumpSkyColor, bumpSkyColor, normalSpec.a);\n  vec4 outColor = vec4(\n      mix(skyColor * diffuseColor, diffuseColor, refraction.r).rgb,\n      diffuseColor.a);\n  // #fogCode\n  gl_FragColor = outColor;\n}\n",
  },
  {
    id: "outerRefractionMapVertexShader",
    content:
      "\nuniform mat4 viewProjection;\nuniform vec3 lightWorldPos;\nuniform mat4 world;\nuniform mat4 viewInverse;\nuniform mat4 worldInverseTranspose;\nattribute vec4 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nattribute vec3 tangent;\nattribute vec3 binormal;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\nvoid main() {\n  v_texCoord = texCoord;\n  v_position = (viewProjection * world * position);\n  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;\n  v_surfaceToLight = lightWorldPos - (world * position).xyz;\n  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;\n  v_binormal = (worldInverseTranspose * vec4(binormal, 0)).xyz;  // #normalMap\n  v_tangent = (worldInverseTranspose * vec4(tangent, 0)).xyz;  // #normalMap\n  gl_Position = v_position;\n}\n\n",
  },
  {
    id: "outerRefractionMapFragmentShader",
    content:
      "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec4 lightColor;\nvarying vec4 v_position;\nvarying vec2 v_texCoord;\nvarying vec3 v_tangent;  // #normalMap\nvarying vec3 v_binormal;  // #normalMap\nvarying vec3 v_normal;\nvarying vec3 v_surfaceToLight;\nvarying vec3 v_surfaceToView;\n\nuniform sampler2D diffuse;\nuniform vec4 specular;\nuniform sampler2D normalMap;  // #normalMap\nuniform sampler2D reflectionMap;\nuniform samplerCube skybox;\nuniform float shininess;\nuniform float specularFactor;\n\nvec4 lit(float l ,float h, float m) {\n  return vec4(1.0,\n              max(l, 0.0),\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\n              1.0);\n}\nvoid main() {\n  vec4 diffuseColor = texture2D(diffuse, v_texCoord);\n  mat3 tangentToWorld = mat3(v_tangent,  // #normalMap\n                             v_binormal,  // #normalMap\n                             v_normal);  // #normalMap\n  vec4 normalSpec = texture2D(normalMap, v_texCoord.xy);  // #normalMap\n  vec4 normalSpec = vec4(0,0,0,0);  // #noNormalMap\n  vec4 reflection = texture2D(reflectionMap, v_texCoord.xy);\n  vec3 tangentNormal = normalSpec.xyz - vec3(0.5, 0.5, 0.5);  // #normalMap\n//  tangentNormal = normalize(tangentNormal + vec3(0,0,refractionFudge));\n  vec3 normal = (tangentToWorld * tangentNormal);  // #normalMap\n  normal = normalize(normal);  // #normalMap\n  vec3 normal = normalize(v_normal);   // #noNormalMap\n\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\n  vec3 surfaceToView = normalize(v_surfaceToView);\n\n  vec4 skyColor = textureCube(skybox, -reflect(surfaceToView, normal));\n  float fudgeAmount = 1.1;\n  vec3 fudge = skyColor.rgb * vec3(fudgeAmount, fudgeAmount, fudgeAmount);\n  float bright = min(1.0, fudge.r * fudge.g * fudge.b);\n  vec4 reflectColor =\n      mix(vec4(skyColor.rgb, bright),\n          diffuseColor,\n          (1.0 - reflection.r));\n  float r = abs(dot(surfaceToView, normal));\n  gl_FragColor = vec4(mix(\n      skyColor,\n      reflectColor,\n      ((r + 0.3) * (reflection.r))).rgb, 1.0 - r);\n}\n",
  },
];

const shaderMap = new Map();
shaders.forEach((shader) => {
  shaderMap.set(shader.id, shader.content);
});

export { shaderMap };
